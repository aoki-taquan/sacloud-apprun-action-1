FROM python:3.12-alpine

# Install Litestream and system dependencies
RUN apk add --no-cache gcc musl-dev linux-headers sqlite-libs curl sqlite \
    && curl -L https://github.com/benbjohnson/litestream/releases/download/v0.3.13/litestream-v0.3.13-linux-amd64.tar.gz | tar -C /usr/local/bin -xzf -

WORKDIR /app

# Copy requirements file
ARG REQUIREMENTS_FILE=requirements.txt
COPY ${REQUIREMENTS_FILE} ./requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Litestream setup script
ARG MAIN_FILE=app.py
COPY <<'EOF' /app/setup-litestream.sh
#!/bin/sh
set -e

if [ -n "$SAKURA_OBJECT_STORAGE_BUCKET" ] && \
   [ -n "$SAKURA_OBJECT_STORAGE_ACCESS_KEY" ] && \
   [ -n "$SAKURA_OBJECT_STORAGE_SECRET_KEY" ] && \
   [ -n "$SQLITE_DB_FOLDER" ]; then

  echo "Configuring Litestream backup for folder: $SQLITE_DB_FOLDER"
  mkdir -p "$SQLITE_DB_FOLDER"
  
  # Create a dummy SQLite database file to track the entire folder
  ARCHIVE_DB="$SQLITE_DB_FOLDER/.litestream_archive.db"
  
  cat > /etc/litestream.yml <<LITESTREAM_EOF
dbs:
  - path: $ARCHIVE_DB
    replicas:
      - type: s3
        endpoint: https://s3.isk01.sakurastorage.jp
        bucket: $SAKURA_OBJECT_STORAGE_BUCKET
        path: ${APP_NAME}/sqlite_archive.db
        access-key-id: $SAKURA_OBJECT_STORAGE_ACCESS_KEY
        secret-access-key: $SAKURA_OBJECT_STORAGE_SECRET_KEY
        sync-interval: ${LITESTREAM_REPLICATE_INTERVAL:-10s}
LITESTREAM_EOF

  # Create backup and restore functions
  create_backup() {
    echo "Creating backup archive of $SQLITE_DB_FOLDER"
    
    # Check if the folder exists and has content
    if [ ! -d "$SQLITE_DB_FOLDER" ]; then
      echo "SQLite folder does not exist, skipping backup"
      return 1
    fi
    
    # Check if there are any database files to backup
    if [ -z "$(find "$SQLITE_DB_FOLDER" -name "*.sqlite*" -o -name "*.db" 2>/dev/null | head -1)" ]; then
      echo "No database files found in $SQLITE_DB_FOLDER, skipping backup"
      return 1
    fi
    
    cd "$(dirname "$SQLITE_DB_FOLDER")" || return 1
    
    # Create tar archive with error checking
    if tar -czf "/tmp/sqlite_backup.tar.gz" "$(basename "$SQLITE_DB_FOLDER")" 2>/dev/null; then
      # Verify the archive was created and is not empty
      if [ -f "/tmp/sqlite_backup.tar.gz" ] && [ -s "/tmp/sqlite_backup.tar.gz" ]; then
        echo "Archive created successfully, size: $(stat -c%s /tmp/sqlite_backup.tar.gz 2>/dev/null || stat -f%z /tmp/sqlite_backup.tar.gz) bytes"
        
        # Store the archive as a blob in the dummy database
        sqlite3 "$ARCHIVE_DB" "CREATE TABLE IF NOT EXISTS backup_archive (id INTEGER PRIMARY KEY, data BLOB, timestamp TEXT);" || return 1
        sqlite3 "$ARCHIVE_DB" "DELETE FROM backup_archive;" || return 1
        
        if sqlite3 "$ARCHIVE_DB" "INSERT INTO backup_archive (data, timestamp) VALUES (readfile('/tmp/sqlite_backup.tar.gz'), datetime('now'));" 2>/dev/null; then
          rm -f "/tmp/sqlite_backup.tar.gz"
          echo "Backup archive created successfully"
          return 0
        else
          echo "Failed to store backup in database"
          rm -f "/tmp/sqlite_backup.tar.gz"
          return 1
        fi
      else
        echo "Failed to create archive or archive is empty"
        rm -f "/tmp/sqlite_backup.tar.gz"
        return 1
      fi
    else
      echo "Failed to create tar archive"
      return 1
    fi
  }

  restore_backup() {
    echo "Attempting to restore databases from backup..."
    if [ -f "$ARCHIVE_DB" ] && sqlite3 "$ARCHIVE_DB" "SELECT COUNT(*) FROM backup_archive;" >/dev/null 2>&1; then
      RECORD_COUNT=$(sqlite3 "$ARCHIVE_DB" "SELECT COUNT(*) FROM backup_archive;")
      if [ "$RECORD_COUNT" -gt 0 ]; then
        echo "Found backup archive with $RECORD_COUNT records, restoring..."
        
        # Extract backup data to temporary file
        if sqlite3 "$ARCHIVE_DB" "SELECT writefile('/tmp/sqlite_restore.tar.gz', data) FROM backup_archive ORDER BY timestamp DESC LIMIT 1;" 2>/dev/null; then
          if [ -f "/tmp/sqlite_restore.tar.gz" ] && [ -s "/tmp/sqlite_restore.tar.gz" ]; then
            echo "Backup file extracted successfully, size: $(stat -c%s /tmp/sqlite_restore.tar.gz 2>/dev/null || stat -f%z /tmp/sqlite_restore.tar.gz) bytes"
            
            # Verify tar file integrity before extraction
            if tar -tzf "/tmp/sqlite_restore.tar.gz" >/dev/null 2>&1; then
              cd "$(dirname "$SQLITE_DB_FOLDER")"
              rm -rf "$(basename "$SQLITE_DB_FOLDER")"
              
              if tar -xzf "/tmp/sqlite_restore.tar.gz"; then
                rm -f "/tmp/sqlite_restore.tar.gz"
                echo "Database folder restored successfully"
              else
                echo "Failed to extract tar archive"
                rm -f "/tmp/sqlite_restore.tar.gz"
              fi
            else
              echo "Backup archive is corrupted"
              rm -f "/tmp/sqlite_restore.tar.gz"
            fi
          else
            echo "Failed to extract backup data or file is empty"
            rm -f "/tmp/sqlite_restore.tar.gz"
          fi
        else
          echo "Failed to write backup data to temporary file"
        fi
      else
        echo "No backup records found in archive database"
      fi
    else
      echo "No backup archive found or archive database is inaccessible"
    fi
  }

  # Create a background process to periodically create backups
  backup_daemon() {
    while true; do
      sleep ${BACKUP_INTERVAL:-30}
      if [ -d "$SQLITE_DB_FOLDER" ]; then
        echo "Running periodic backup..."
        create_backup || echo "Periodic backup failed"
      else
        echo "SQLite folder not found, skipping periodic backup"
      fi
    done
  }

  # Initialize dummy database if it doesn't exist
  if [ ! -f "$ARCHIVE_DB" ]; then
    sqlite3 "$ARCHIVE_DB" "CREATE TABLE IF NOT EXISTS backup_archive (id INTEGER PRIMARY KEY, data BLOB, timestamp TEXT);"
  fi

  # First, try to restore from Litestream backup
  /usr/local/bin/litestream restore -config /etc/litestream.yml -if-replica-exists || echo "No Litestream backups found"
  
  # Then restore from the archive
  restore_backup

  # Create initial backup if folder has content
  if [ -d "$SQLITE_DB_FOLDER" ] && [ -n "$(find "$SQLITE_DB_FOLDER" -name "*.sqlite*" -o -name "*.db" 2>/dev/null | head -1)" ]; then
    echo "Found existing database files, creating initial backup..."
    create_backup || echo "Initial backup creation failed, but continuing..."
  else
    echo "No existing database files found, skipping initial backup"
  fi

  # Start backup daemon in background
  backup_daemon &

  echo "Starting with Litestream backup..."
  exec /usr/local/bin/litestream replicate -config /etc/litestream.yml -exec "python MAIN_FILE_PLACEHOLDER"
else
  echo "Starting without backup..."
  exec python MAIN_FILE_PLACEHOLDER
fi
EOF

# Replace placeholder with actual main file
RUN sed -i "s/MAIN_FILE_PLACEHOLDER/${MAIN_FILE}/g" /app/setup-litestream.sh

RUN chmod +x /app/setup-litestream.sh

ARG PORT=8080
ENV PORT=$PORT
EXPOSE $PORT

ENTRYPOINT ["/app/setup-litestream.sh"]
